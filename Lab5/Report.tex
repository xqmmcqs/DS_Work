\documentclass{article}

\usepackage{ctex}
\usepackage[top=0.7in,bottom=0.7in,left=0.5in,right=0.5in]{geometry}
\usepackage{array}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{fontspec}
\newfontfamily\consolas{Consolas}
\usepackage{xcolor} % 定制颜色
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
backgroundcolor=\color{white},      % choose the background color
basicstyle=\footnotesize\ttfamily,  % size of fonts used for the code
columns=fullflexible,
tabsize=4,
breaklines=true,               % automatic line breaking only at whitespace
captionpos=b,                  % sets the caption-position to bottom
commentstyle=\color{mygreen},  % comment style
escapeinside={\%*}{*)},        % if you want to add LaTeX within your code
keywordstyle=\color{blue},     % keyword style
stringstyle=\color{mymauve}\ttfamily,  % string literal style
frame=single,
rulesepcolor=\color{red!20!green!20!blue!20},
% identifierstyle=\color{red},
language=c++,
}

\newcommand{\hmwkTitle}{求有向无环图最长路径\ 实验报告}
\newcommand{\hmwkClass}{数据结构}
\newcommand{\hmwkClassInstructor}{}
\newcommand{\hmwkAuthorName}{毛子恒\ 李臻\ 张梓靖}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ : \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\title{\hmwkClass\ ：\hmwkTitle}
\author{\hmwkAuthorName}

\setcounter{tocdepth}{1}

\begin{document}

\maketitle

\section*{小组成员}

\setlength{\tabcolsep}{9mm}
{
    \begin{table}[htbp]
        \centering
        \begin{tabular}{llll}
            班级：2019211309 & 姓名：毛子恒 & 学号：2019211397 & 分工：代码\ 文档   \\

            班级：2019211310 & 姓名：李臻   & 学号：2019211458 & 分工：测试\ 文档   \\

            班级：2019211308 & 姓名：张梓靖 & 学号：2019211379 & 分工：可视化\ 文档 \\
        \end{tabular}
    \end{table}
}

\tableofcontents
\newpage

\section{需求分析}

\subsection{题目描述}

给定一个有向无环图，找到图中距离最远的两个结点。

\subsection{输入描述}

程序从标准输入中读入数据。

输入的第一行包含两个整数$n,m$，用空格分隔，分别表示有向无环图的点数和边数。

接下来的$m$行，每行三个整数，用空格分隔，分别表示每个弧的弧尾、弧头和权值，顶点编号$x$的范围满足$1\leq x\leq n$，权值为正数。

\subsection{输出描述}

程序向标准输出中输出结果。

输出分为以下五种情况：

\begin{enumerate}
    \item 输入合法，程序正常运行结束，此时输出一行三个整数，用空格分隔，分别表示最长的距离和最长的两个顶点的编号。
    \item 输入的有向无环图没有边，此时程序输出一个字符串“No solution.”表示无解。
    \item 输入的有向无环图结点数不足2个，此时程序输出一个字符串“there should be at least two points!”。
    \item 输入的弧头、弧尾或者权值信息范围有误，此时程序输出一个字符串“Invalid input.”。
    \item 程序发生运行时错误，比如内存分配失败等，此时程序没有输出。
\end{enumerate}

\subsection{样例输入输出}

\subsubsection{样例输入输出1}

【输入】

\begin{lstlisting}[
    basicstyle=\small\consolas]
aaababcd
\end{lstlisting}

【输出】

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

\subsubsection{样例输入输出2}

【输入】(samples/sample2.in)

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

【输出】(samples/sample2.out)

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

\subsubsection{样例输入输出3}

【输入】(samples/sample3.in)

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

【输出】(samples/sample3.out)

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

\subsubsection{样例输入输出4}

【输入】

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

【输出】

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

\subsubsection{样例输入输出5}

【输入】

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

【输出】

\begin{lstlisting}[
    basicstyle=\small\consolas]
\end{lstlisting}

\subsection{程序功能}

程序找到图中距离最大的两个点并且输出这两个点及其距离。

\section{概要设计}

\subsection{问题解决的思路}

程序建立采用邻接表存储的图，求出从源点（虚拟的）开始到每个顶点的距离及其路径，找到距离源点距离最大的点并且输出。

\subsection{有向无环图的设计}

\begin{lstlisting}[language={C},
    numbers=left,
    numberstyle=\tiny\consolas,
    basicstyle=\small\consolas]
// 数据对象
typedef struct edge
{
    int v, val;
    struct edge * next;
} Edge;

extern int n, m; // n为点数，m为边数
extern int * ind; // 各个顶点的入度
extern int * dist; // 源点至各个顶点的最短距离
extern int * par; // 源点至此点的最短路径中，上一个顶点的编号
extern Edge ** firstEdge;

/*
 * 操作：初始化有向无环图
 * 后件：初始化firstEdge、ind、dist、par数组
 */
void initGraph();

/*
 * 操作：向图中加入弧
 * 前件：u,v是弧尾、弧头的编号，val是弧的权值
 * 后件：图中加入这条边
 */
void addEdge(int u, int v, int val);

/*
 * 操作：有向无环图的拓扑排序，求出dist和par数组的值
 * 前件：firstEdge中存储有向无环图的信息
 * 后件：dist中存储源点至各个点的最短距离，par中记录最短路径
 */
void topologicalSort();

/*
 * 操作：释放有向无环图的空间
 * 后件：释放各条边的空间，以及firstEdge、ind、dist、par数组的空间
 */
void destroyGraph();
\end{lstlisting}

\subsection{主程序的流程}

\begin{enumerate}
    \item 获取输入，判断是否构成图
    \item 如果能构成图，则初始化图，后向图中加入弧
    \item 将有向无环图拓扑排序，记录源点到各个顶点的最短距离和至该点的上一顶点的编号
    \item 比较最短距离，找到图中的最长路径，并根据顶点编号输出路径
    \item 释放有向无环图的空间
\end{enumerate}

\subsection{各程序模块之间的层次关系}

程序模块层次关系图如图1。

\begin{figure}[htbp]

    \centering\includegraphics[width=0.4\textwidth]{./Images/pic5_1.png}

    \caption{程序模块层次关系}

\end{figure}

\section{详细设计}

\subsection{图的实现}

有向无环图的设计中基本操作的伪代码算法如下：

\begin{lstlisting}[language={C},
    numbers=left,
    numberstyle=\tiny\consolas,
    basicstyle=\small\consolas]
// 初始化有向无环图
void initGraph()
{
    初始化firstEdge、ind、dist、par数组并分配内存
    if (内存分配失败)
        异常退出
}

// 向图中加入边
void addEdge(int u, int v, int val)
{
    设置临时边temp存放待加入的边
    if (内存分配失败)
        异常退出
    temp->val <- val
    temp->v <- v
    temp->next <- firstEdge[u]
    firstEdge[u] <- temp
    v的入度+1
}

// 有向无环图的拓扑排序
void topologicalSort()
{
    定义 * stac, tot <- -1
    if (stac内存分配失败)
        异常退出
    遍历所有顶点
    {   if (编号i的顶点入度为0)
        {
            记录编号i
            源点至此点的最短路径中，上一个顶点的编号置为-1
            i的最短路径置为0
        }
        else dist[i] <- 无穷
    }
    遍历入度为0的顶点
    {
        定义 u 为最后一个入度为0的点
        for (Edge * i <- firstEdge[u]; i; i <- i->next)
        {
            int v <- i->v
            if (dist[u] + i->val < dist[v])
            {
                dist[v] <- dist[u] + i->val
                par[v] <- u
            }
            v的入度-1
            if (v的入度不为0)
                stac[++tot] <- v
        }
    }
    释放stac数组的空间
}

// 释放有向无环图的空间
void destroyGraph()
{
    释放有向无环图各条边的空间，以及firstEdge、ind、dist、par数组的空间
}
\end{lstlisting}

\subsection{函数的调用关系图}

函数调用关系图如图2。

\begin{figure}[htbp]

    \centering\includegraphics[width=0.4\textwidth]{./Images/pic5_2.png}

    \caption{函数调用关系图}

\end{figure}

\section{调试分析报告}

\subsection{调试过程中遇到的问题和思考}

由于对二进制文件的输入、输出不熟悉，曾尝试使用printf和scanf函数进行输入输出，了解相关知识后改为调用fread和
fwrite函数。

在解码的过程中feof函数经常出现探测文件末尾不准确，故改为判断fread函数是否为0来结束循环。

在构造哈夫曼树的过程中由于判断条件过于复杂，出现错误；改为了更简洁的判断条件。

在写入到压缩文件之前，压缩码需要以'0'/'1'字符串的形式存储，否则调用各种字符串函数会出现错误。

编码以8位压缩到一个字节当中，写入和读取的时候注意高低位的顺序。

\subsection{设计实现的回顾讨论}

编码是每次从二进制文件中读入1024个字节，创建编码表并且压缩。

由于哈夫曼树结点数较少，所以存储下标时采用short类型，写入压缩文件时可以节省空间。

对于没有出现过的字符显然不需要编码。调用库函数qsort对权值进行排序。

哈夫曼树采取顺序存储结构，前$n$个结点为叶节点，之后$n-1$个结点为非叶节点，每次构造新的非叶节点时只需要比较
叶节点中权值最小的两个结点和非叶节点中权值最小的两个结点，从中挑出权值最小的两个结点即可，使得查找结点的时间
复杂度降低到$O(1)$

压缩后的串为一个01串，将其每8位压缩到一个字节并写入压缩文件。

对于只有一种字符的情况，由于无法建立哈夫曼树，所以压缩文件中只存储tot、该字符、原字符串的长度。编码和解码是均
对这种情况特殊处理。

\subsection{算法复杂度分析}

encode,decode函数的复杂度为$O(len)$，其中$len$为字符串长度。

主函数的时间复杂度为$O(1)$，整体时间复杂度为$O(len)$。

\subsection{改进设想的经验和体会}

\subsubsection{改进1}

可以通过进一步压缩位（比如去掉一定为0的某些字节）来使得压缩率更高，但是编程复杂度会显著提高。

\subsubsection{改进2}

可以判断如果压缩率大于1，则直接写入原文件。

\section{用户使用说明}

使用gcc编译生成可执行文件。

\begin{lstlisting}[language={bash},
    basicstyle=\small\consolas]
gcc -o main -std=c11 main.c huffman.c
\end{lstlisting}

执行可执行文件：

\begin{lstlisting}[language={bash},
    basicstyle=\small\consolas]
./main
\end{lstlisting}

在Windows cmd下：

\begin{lstlisting}[language={bash},
    basicstyle=\small\consolas]
main
\end{lstlisting}

之后将数据写入到指定文件中，可以通过标准输入选择选项，也可以通过执行可执行文件时传递参数来选择选项：

\begin{enumerate}
    \item 如果执行可执行文件时没有传递参数，则可以根据标准输入的提示选择压缩/解压功能，以及指定输入和输出文件的位置
    \item 执行可执行文件时传递的参数：第一个参数为1或2，表示选择压缩/解压，之后两个参数分别为输入文件的路径和输出文件的路径，例如，执行
\begin{lstlisting}[language={bash},
    basicstyle=\small\consolas]
./main 1 ./input.in ./output.out
\end{lstlisting}
    表示执行压缩功能，输入文件为本目录下的input.in，输出文件为本目录下的output.out
\end{enumerate}

通过标准输出打印提示信息。如果输入合法并且程序正常运行结束，主函数返回值为0。

\section{测试结果}

测试环节分为三个步骤。

\subsection{测试第一部分}

对1.4节给出的样例进行测试。

\subsection{测试第二部分}

测试边界条件。

【输入】(samples/sample4.in)

（空文件）

【输出】(samples/sample4.out)

（空文件）

【输入】(samples/sample5.in)

文件内容为1000000个字符a

【输出】(samples/sample5.out)

压缩结果为一个8873字节的二进制文件。

【输入】

上一个例子的输出。

【输出】(samples/sample6.out)

解压与sample5.in相同。

\subsection{测试第三部分}

测试在macOS\ Big\ Sur\ 11.0.1下进行。

在$len<=10$，$len<=100$，$n<=1000000$的范围下分别随机生成1000组测试数据，进行压缩和解压操作，并且比对解压结果和原始输入是否相同。

3000组数据中没有出现错误。

数据生成程序(testing/data.cpp)如下：

\begin{lstlisting}[language={C++},
    numbers=left,
    numberstyle=\tiny\consolas,
    basicstyle=\small\consolas]
#include <bits/stdc++.h>
using namespace std;

int main(int argc, char *argv[])
{
    srand(time(0));
    FILE *file = fopen("./raw.in", "wb");
    int n = atoi(argv[1]), m = atoi(argv[2]);
    for (int i = 1; i <= n; ++i)
        fprintf(file, "%c", rand() % m + 32);
    fclose(file);
    return 0;
}
\end{lstlisting}

传入两个参数，第一个参数是字符串的长度，第二个参数是字符集的大小。

比对脚本(testing/chk.sh)如下：

\begin{lstlisting}[language={bash},
    numbers=left,
    numberstyle=\tiny\consolas,
    basicstyle=\small\consolas]
for i in {1..100}
do
    sleep 1
    ./data 100000 5
    ./main 1 raw.in encode.out
    ./main 2 encode.out decode.out
    if ! diff raw.in decode.out
    then
        break
    fi
    echo "Correct"
done
\end{lstlisting}

\section{可视化}

随机生成若干组数据，使用该程序进行压缩，记录不同数据规模下的平均压缩率，并且使用JavaScript将结果可视化。

比对脚本(testing/test.py)如下：

\begin{lstlisting}[language={python},
    numbers=left,
    numberstyle=\tiny\consolas,
    basicstyle=\small\consolas]
import os
import time

with open("./result.txt", "w") as file:
    for i in (10, 30, 50, 100, 500, 1000, 10000, 1000000):
        for j in (3, 6, 10, 20, 30, 50, 95):
            tot = 0
            for k in range(100):
                time.sleep(1)
                os.system("./data {0} {1}".format(i, j))
                os.system("./main 1 raw.in out.out")
                tot += os.path.getsize("./out.out") / \
                    os.path.getsize("./raw.in")
            file.write("[{0}, {1}, {2}],\n".format(i, j, str(tot / 10)[:9]))
\end{lstlisting}

数据规模如下：

$len=10,30,50,100,500,1000,10000,1000000$，字符集大小$=3,6,10,20,30,60,95$的数据各100组，共5600组数据。

\subsubsection{实现细节}

利用已有的压缩率数据，使用Highcharts库绘制散点图。

\subsubsection{用户使用说明}

使用现代浏览器打开Scatter/index.html，即可看到散点图，将鼠标指针放到某个点上可以看到对应的数据值，拖动图表可以从不同角度观察数据分布。

\subsubsection{示例}

见图3。

\begin{figure}[htbp]
    
    % \centering\includegraphics[width=0.9\textwidth]{./Images/pic4_2_3.png}
    
    \caption{可视化示例}
    
\end{figure}

\subsubsection{结论}

可以观察到在字符串长度较小的时候和字符集大小较大的时候压缩率有明显上升，理想情况下在字符集大小在20以内，字符串大小在100以上会有比较好的压缩效果。

\end{document}
